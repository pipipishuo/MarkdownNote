# cr0寄存器

开发手册  volume3.A  2.5CONTROL REGISTERS    3137页

cro 管着保护模式 分页开启



# cr3寄存器

开发手册  volume3.A  2.5CONTROL REGISTERS  还有就是Use of CR3 with Ordinary 4-Level Paging and 5-Level Paging 因为cr3就是负责分页的 所以放这里也很合适  说白了就是把信息存哪



关于cr3的位数    开发手册3187页  NOTES那里

```
CR3 has 64 bits on processors supporting the Intel-64 architecture. These bits are ignored with 32-bit paging.
```



cr3寄存器就管着两个事儿 一个是存放页的物理地址 第二个是pcid  pcid是一种跟TLB缓存有关



关于pcid相关设置看这

```
5.10.1 Process-Context Identifiers (PCIDs)
Process-context identifiers (PCIDs) are a facility by which a logical processor may cache information for multiple linear-address spaces. The processor may retain cached information when software switches to a different linear address space with a different PCID (e.g., by loading CR3; see Section 5.10.4.1 for details).
A PCID is a 12-bit identifier. Non-zero PCIDs are enabled by setting the PCIDE flag (bit17) of CR4. If CR4.PCIDE = 0, the current PCID is always 000H; otherwise, the current PCID is the value of bits 11:0 of CR3.1 Not all processors allow CR4.PCIDE to be set to 1; see Section 5.1.4 for how to determine whether this is allowed.
```





## pcid

#### 是什么？

PCID 是英特尔和 AMD 处理器引入的一种特性，用于解决上述 TLB 冲刷的性能问题。

#### 它是如何工作的？

1. **给 TLB 条目打标签**： 有了 PCID，TLB 里的每一个缓存条目不再仅仅是地址映射，它还附带了一个标签，即 **PCID**（一个数字，通常是 12 位，允许 4096 个不同的 ID）。
2. **扩展 CR3 寄存器**： 现代的 `CR3` 寄存器不再是简单的物理地址。它的结构变成了：
   - **高位数**： 页表物理地址（由于对齐要求，低12位总是0）。
   - **低12位**： **PCID** 字段。
3. **智能的 TLB 查找**： 当 CPU 进行地址翻译时，它不仅要看虚拟地址是否匹配，还要看当前 `CR3` 中的 PCID 是否与 TLB 条目的 PCID 标签匹配。
4. **解决核心问题**：
   - 当从进程 A（PCID=1）切换到进程 B（PCID=2）时，操作系统只需修改 `CR3` 值为 B 的页表地址 **并** 将 PCID 字段设置为 2。
   - **CPU 不再需要清空整个 TB**！
   - CPU 在查找 TLB 时，由于现在 `CR3.PCID=2`，它只会找到那些标签为 2 的 TLB 条目（属于进程 B），而会忽略标签为 1 的条目（属于进程 A）。
   - 当切换回进程 A 时，只需将 `CR3` 改回 A 的页表地址并将 PCID 设为 1，进程 A 之前缓存在 TLB 中的条目立刻就能被找到并使用，几乎没有性能损失。

# MSR寄存器



```
model specific register (MSR) 缩写
```

相关指令

```
RDMSR  	读
WRMSR	写
```





# IA-32E模式

## 模式的说明

手册位置 Vol. 3A 2-7   2.2 MODES OF OPERATION 



这个里面说的很明确了

```
Intel 64 architecture supports all operating modes of IA-32 architecture and IA-32e modes:

•IA-32e mode — In IA-32e mode, the processor supports two sub-modes: compatibility mode and 64-bit

mode. 64-bit mode provides 64-bit linear addressing and support for physical address space larger than 64

GBytes. Compatibility mode allows most legacy protected-mode applications to run unchanged.
```



## 初始化顺序

这个就是启用64位虚拟地址  妈的 叫这么个逼名

文档位置  11.8.5 Initializing IA-32e Mode   

```
Operating systems should follow this sequence to initialize IA-32e mode:

1. Starting from protected mode, disable paging by setting CR0.PG = 0. Use the MOV CR0 instruction to disable paging (the instruction must be located in an identity-mapped page).

2. Enable physical-address extensions (PAE) by setting CR4.PAE = 1. Failure to enable PAE will result in a #GPfault when an attempt is made to initialize IA-32e mode.

3. Load CR3 with the physical base address of the Level 4 page map table (PML4) or Level 5 page map table(PML5).

4. Enable IA-32e mode by setting IA32_EFER.LME = 1.
  
5. Enable paging by setting CR0.PG = 1. This causes the processor to set the IA32_EFER.LMA bit to 1. The MOV CR0 instruction that enables paging and the following instructions must be located in an identity-mapped page (until such time that a branch to non-identity mapped pages can be effected).
```

对于步骤四具体指令看这里 看开发手册4665页  Register Address: C000_0080H  可搜索关键字“Enables IA-32e mode operation”

# 分页

开发手册 5.3 32-BIT PAGING  这个讲的是32位的

4级5级的区别以及能够用的物理地址数都在这段话中

```
5.5 4-LEVEL PAGING AND 5-LEVEL PAGING
Because the operation of 4-level paging and 5-level paging is very similar, they are described together in this 
section. The following items highlight the distinctions between the two paging modes:
• A logical processor uses 4-level paging if CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 0. 
4-level paging translates 48-bit linear addresses to 52-bit physical addresses.1 Although 52 bits corresponds to 
4 PBytes, linear addresses are limited to 48 bits; at most 256 TBytes of linear-address space may be accessed 
at any given time.
• A logical processor uses 5-level paging if CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 1. 
5-level paging translates 57-bit linear addresses to 52-bit physical addresses. Thus, 5-level paging supports a 
linear-address space sufficient to access the entire physical-address space.
```

